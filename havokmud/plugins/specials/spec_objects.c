#include "config.h"
#include "environment.h"
#include "platform.h"
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include <time.h>

#include "protos.h"
#include "externs.h"



extern struct time_info_data time_info;

int randomitem(void);

void            printmap(struct char_data *ch, int x, int y, int sizex,
                         int sizey);
int             CanSail(struct obj_data *obj, int direction);
int ReadObjs(FILE * fl, struct obj_file_u *st);

char            oceanmap[101][260] = {
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=+++++"
    "+++++++++++++++++++++++++++++",
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "+++++++++++++++++++++++++++++",
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "+++++++++++++++++++++++++++++",
    "++++++++++++++++++++.....++++++++++.................++++++++++++++++++++++"
    "++++++++++++++++++++++++............++++++++++....++++++~~~~~~~~~~..++++++"
    "++++++++~~~..+++++++++++++++~~~~~~~~~~~~~~~~~~..++++++++++++++++++++++++++"
    "+++++++++++++++++++++++++++++",
    "++++++++++++++++++++++...................................................."
    ".........................................................................."
    "................................................++++++++++++++++++++++++++"
    "+++++++++++++++++++++++++++++",
    "+++++++++++++++++++....~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~..+++++++++++++++++++"
    "+++++++++++++++++++++++++++++",
    "++++++++++++.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~..++++++++++++++++++++++"
    "+++++++++++++++++++++++++++++",
    "++++++++++++++++....~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~..++++++++++"
    "+++++++++++++++++++++++++++++",
    "+++++++++++++++..~~.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~..++++"
    "+++++++++++++++++++++++++++++",
    "++++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~..+++++++++++++++++++++++++",
    "+++++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~..+++++++++++++++++++++++++",
    "+++++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~..++++++++++++++++",
    "+++++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "+++++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~:::::::~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~:::::~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "+++++++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~:::::::@~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~.............."
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~::......[]..~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~..............."
    ".~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~:.................~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~..///+++++++++//"
    "..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~:.........^^^^^^....~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~../++++++++++++++"
    "+++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "+++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~:......^^^^^^^^^^....~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~.../+++++++++++++/"
    "....~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~++++++~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "+++++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~::..^^^^^^^^^^^^^^..~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~..//+++++++++++..."
    "%%%%%~~...~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~..+++..~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "+++++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~:..^^^^^^^^^^^^^^..~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~..///^^^...%%%%~~~"
    "...~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~..+++.~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~:..^^^^^^^^^^^^^^..~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~..//^^^.~~~.[City]"
    "...~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~......~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~:....^^^^^^^^^^....~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~../^^^^~~~~..//@1/"
    "...~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~....^^^^^^^....~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~../^^^^^^..////|/"
    "/..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~....@...~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~../^^^^^^^/....|."
    "..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~../////////..~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~............~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~.........~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~:::::::~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~:::::~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~:::::::~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~:::::~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++..........~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~..+++++++++++",
    "++++++++++++.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~..+++++++++++++",
    "++++++++++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~..+++++++++++++++",
    "++++++++++++.......~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~............~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~++~++++++++++",
    "+++++++.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~....+++++++++++++++++......~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~..+++++++++++++++++++++",
    "+++++++++++++..~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    "~~~~~~~~~~~~~~.......+++++++++++++++++++++++++........~~~~~~~~~~~~~~~~~~~~"
    "~.+++++++++++++++++++++++++++",
    "++++++++++++++++.........................................................."
    ".........................................................................."
    "...............++++++++++++++++++++++++++++++++++++++....................+"
    "+++++++++++++++++++++++++++++",
    "+++++++++++++..++++++++++................+++++++++++++++++++++++++++++++++"
    "+++++++++++++............++++++++++....++++++~~~~~~~~~~..++++++++++++++~~~"
    "..+++++++++++++++~~~~~~~~~~~~~~~~~~..+++++++++++++++++++++++++++++++++++++"
    "+++++++++++++++++++++++++++++",
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "+++++++++++++++++++++++++++++",
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "+++++++++++++++++++++++++++++",
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "+++++++++++++++++++++++++++++",
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "+++++++++++++++++++++++++++++",
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "+++++++++++++++++++++++++++++",
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    "+++++++++++++++++++++++++++++"
};



/***********
 * Start of object procs
 */

int nodrop(struct char_data *ch, int cmd, char *arg, struct obj_data *tobj,
           int type)
{
    struct index_data *index;
    struct char_data *t = NULL;
    struct obj_data *obj,
                   *i;
    char            buf[80],
                   *obj_name,
                   *vict_name,
                   *name;
    bool            do_all;
    int             j,
                    num;
    Keywords_t     *key;

    switch (cmd) {
    case 10:                    /* Get */
    case 60:                    /* Drop */
    case 72:                    /* Give */
    case 156:                   /* Steal */
        break;
    default:
        return (FALSE);
    }

    if (type != PULSE_COMMAND) {
        return (FALSE);
    }

    arg = get_argument(arg, &obj_name);
    if (!obj_name) {
        return (FALSE);
    }

    obj = NULL;
    do_all = FALSE;
    key = NULL;

    if (!strncmp(obj_name, "all", 3)) {
        do_all = TRUE;
        num = IS_CARRYING_N(ch);
    } else {
        strcpy(buf, obj_name);
        name = buf;
        if (!(num = get_number(&name))) {
            return (FALSE);
        }
        key = StringToKeywords( name, NULL );
    }

    /*
     * Look in the room first, in get case
     */
    if (cmd == 10) {
        for (i = real_roomp(ch->in_room)->contents, j = 1; 
             i && (j <= num);
             i = i->next_content) {
            if (i->item_number >= 0 && 
                (do_all || KeywordsMatch(key, &i->keywords))) {

                if( !do_all && j != num ) {
                    j++;
                    continue;
                }

                if (i->index->func == nodrop) {
                    obj = i;
                    break;
                }
            }
        }
    }

    /*
     * Check the character's inventory for give, drop, steal.
     */
    if (!obj && cmd == 10) {
        /*
         * Don't bother with get anymore
         */
        FreeKeywords(key, TRUE);
        return (FALSE);
    }

    for (i = ch->carrying, j = 1; i && (j <= num); i = i->next_content) {
        if (i->item_number >= 0 && 
            (do_all || KeywordsMatch(key, &i->keywords))) {

            if( !do_all && j != num ) {
                j++;
                continue;
            }

            if (i->index->func == nodrop) {
                obj = i;
                break;
            } 
            
            if (!do_all) {
                FreeKeywords(key, TRUE);
                return (FALSE);
            }
        }
    }

    FreeKeywords(key, TRUE);

    /*
     * Musta been something else
     */
    if (!obj) {
        return (FALSE);
    }

    if (cmd == 72 || cmd == 156) {
        vict_name = skip_spaces(arg);
        if (!vict_name || !(t = get_char_room_vis(ch, vict_name))) {
            return (FALSE);
        }
    }

    switch (cmd) {

    case 10:
        if (GetMaxLevel(ch) <= MAX_MORT) {
            act("$p disintegrates when you try to pick it up!",
                FALSE, ch, obj, 0, TO_CHAR);
            act("$n tries to get $p, but it disintegrates in his hand!",
                FALSE, ch, obj, 0, TO_ROOM);
            objectExtract(obj);
            if (do_all) {
                return (FALSE);
            } else {
                return (TRUE);
            }
        } else {
            return (FALSE);
        }
        break;
    case 60:
        if (!IS_OBJ_STAT(obj, extra_flags, ITEM_NODROP)) {
            act("You drop $p to the ground, and it shatters!",
                FALSE, ch, obj, 0, TO_CHAR);
            act("$n drops $p, and it shatters!", FALSE, ch, obj, 0, TO_ROOM);

            i = objectRead(30, VIRTUAL);
            sprintf(buf, "Scraps from %s lie in a pile here.",
                    obj->short_description);
            i->description = (char *) strdup(buf);
            objectPutInRoom(i, ch->in_room);
            objectTakeFromChar(obj);
            objectExtract(obj);

            if (do_all) {
                return (FALSE);
            } else {
                return (TRUE);
            }
        } else {
            return (FALSE);
        }
        break;

    case 72:
        if (!IS_OBJ_STAT(obj, extra_flags, ITEM_NODROP)) {
            if (GetMaxLevel(ch) <= MAX_MORT) {
                act("You try to give $p to $N, but it vanishes!",
                    FALSE, ch, obj, t, TO_CHAR);
                act("$N tries to give $p to you, but it fades away!",
                    FALSE, t, obj, ch, TO_CHAR);
                act("As $n tries to give $p to $N, it vanishes!",
                    FALSE, ch, obj, t, TO_ROOM);
                objectExtract(obj);
                if (do_all) {
                    return (FALSE);
                } else {
                    return (TRUE);
                }
            } else {
                return (FALSE);
            }
        } else {
            return (FALSE);
        }
        break;

    case 156:
        /*
         * Steal
         */
        if (!IS_OBJ_STAT(obj, extra_flags, ITEM_NODROP)) {
            act("You cannot seem to steal $p from $N.",
                FALSE, ch, obj, t, TO_CHAR);
            act("$N tried to steal something from you!", FALSE, t, obj, ch,
                TO_CHAR);
            act("$N tried to steal something from $n!", FALSE, t, obj, ch,
                TO_ROOM);
            return (TRUE);
        } else {
            return (FALSE);
        }
        break;

    default:
        return (FALSE);
        break;
    }

    return (FALSE);
}

int soap(struct char_data *ch, int cmd, char *arg, struct obj_data *tobj,
         int type)
{
    struct index_data *index;
    struct char_data *t;
    struct obj_data *obj;
    char           *dummy,
                   *name;
    int             (*wash) ();

    wash = soap;

    if (type != PULSE_COMMAND) {
        return (FALSE);
    }

    if (cmd != 172) {
        return (FALSE);
    }

    if (!(obj = ch->equipment[HOLD])) {
        return (FALSE);
    }

    if (obj->index->func != wash) {
        return (FALSE);
    }

    arg = get_argument(arg, &dummy);
    if (!dummy) {
        return (FALSE);
    }

    name = skip_spaces(arg);
    if (!name) {
        return (FALSE);
    }

    if (!(t = get_char_room_vis(ch, name))) {
        return (FALSE);
    }

    if (affected_by_spell(t, SPELL_WEB)) {
        affect_from_char(t, SPELL_WEB);
        act("$n washes some webbing off $N with $p.", TRUE, ch, obj, t,
            TO_ROOM);
        act("You wash some webbing off $N with $p.", FALSE, ch, obj, t,
            TO_CHAR);
    } else {
        act("$n gives $N a good lathering with $p.", TRUE, ch, obj, t,
            TO_ROOM);
        act("You give $N a good lathering with $p.", FALSE, ch, obj, t,
            TO_CHAR);
    }

    obj->value[0]--;
    if (!obj->value[0]) {
        act("That used up $p.", FALSE, ch, obj, t, TO_CHAR);
        objectExtract(obj);
    }
    return( TRUE );
}

#define ENTER 7
int portal(struct char_data *ch, int cmd, char *arg, struct obj_data *obj,
           int type)
{
    struct obj_data *port;
    char           *obj_name;

    if (type == PULSE_COMMAND) {
        if (cmd != ENTER) {
            return (FALSE);
        }
        arg = get_argument(arg, &obj_name);
        if (!obj_name ||
            !(port = get_obj_in_list_vis(ch, obj_name,
                                         real_roomp(ch->in_room)->contents))) {
            return (FALSE);
        }

        if (port != obj) {
            return (FALSE);
        }
        if (port->value[1] <= 0 || port->value[1] > 80000) {
            /* 
             * see hash.h Mythos 
             */
            send_to_char("The portal leads nowhere\n\r", ch);
            return( FALSE );
        }

        act("$n enters $p, and vanishes!", FALSE, ch, port, 0, TO_ROOM);
        act("You enter $p, and you are transported elsewhere", FALSE, ch,
            port, 0, TO_CHAR);
        char_from_room(ch);
        char_to_room(ch, port->value[1]);
        do_look(ch, NULL, 0);
        act("$n appears from thin air!", FALSE, ch, 0, 0, TO_ROOM);
    } else {
        obj->value[0]--;
        if (obj->value[0] == 0) {
            if (obj->in_room != NOWHERE && real_roomp(obj->in_room)->people) {
                act("$p vanishes in a cloud of smoke!", FALSE,
                    real_roomp(obj->in_room)->people, obj, 0, TO_ROOM);
                act("$p vanishes in a cloud of smoke!", FALSE,
                    real_roomp(obj->in_room)->people, obj, 0, TO_CHAR);
            }
            objectExtract(obj);
        }
    }
    return( TRUE );
}

int scraps(struct char_data *ch, int cmd, char *arg, struct obj_data *obj,
           int type)
{
    if (type == PULSE_COMMAND) {
        return (FALSE);
    } else {
        if (obj->value[0]) {
            obj->value[0]--;
        }
        if (obj->value[0] == 0 && obj->in_room) {
            if (obj->in_room != NOWHERE && real_roomp(obj->in_room)->people) {
                act("$p disintegrates into atomic particles!", FALSE,
                    real_roomp(obj->in_room)->people, obj, 0, TO_ROOM);
                act("$p disintegrates into atomic particles!", FALSE,
                    real_roomp(obj->in_room)->people, obj, 0, TO_CHAR);
            }
            objectExtract(obj);
        }
    }
    return( TRUE );
}

long            jackpot = 25;

int SlotMachine(struct char_data *ch, int cmd, char *arg,
                struct obj_data *obj, int type)
{
    int             c,
                    i[3],
                    ind = 0;
    char            buf[255];

    if (cmd != 224) {
        return (FALSE);
    }
    if (GET_GOLD(ch) < 25) {
        send_to_char("You don't have enough gold!\n\r", ch);
        return (TRUE);
    }

    if (jackpot == 0) {
        /* 
         * always at LEAST have 25 in there 
         */
        jackpot = 25; 
    }

    GET_GOLD(ch) -= 25;
    jackpot += 25;

    for (c = 0; c <= 2; c++) {
        i[c] = number(1, 28);
        switch (i[c]) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
            i[c] = 0;
            sprintf(buf, "Slot %d: Lemon\n\r", c);
            send_to_char(buf, ch);
            break;
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
            i[c] = 1;
            sprintf(buf, "Slot %d: Orange\n\r", c);
            send_to_char(buf, ch);
            break;
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
            i[c] = 2;
            sprintf(buf, "Slot %d: Banana\n\r", c);
            send_to_char(buf, ch);
            break;
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
            i[c] = 3;
            sprintf(buf, "Slot %d: Peach\n\r", c);
            send_to_char(buf, ch);
            break;
        case 26:
        case 27:
            i[c] = 4;
            sprintf(buf, "Slot %d: Bar\n\r", c);
            send_to_char(buf, ch);
            break;
        case 28:
            i[c] = 5;
            sprintf(buf, "Slot %d: Gold\n\r", c);
            send_to_char(buf, ch);
            break;
        }

    }

    if (i[0] == i[1] && i[1] == i[2]) {
        /* 
         * Ok, they've won, now how much? 
         */
        send_to_char("You've won!\n\r", ch);

        switch (i[0]) {
        case 0:
            /* 
             * Give them back what they put in 
             */
            ind = 25;
            break;
        case 1:
            ind = 100;
            break;
        case 2:
            ind = 200;
            break;
        case 3:
            ind = 500;
            break;
        case 4:
            ind = 1000;
            break;
        case 5:
            /* 
             * Wow! We've won big! 
             */
            ind = jackpot; 
            act("Sirens start sounding and lights start flashing everywhere!", 
                FALSE, ch, 0, 0, TO_ROOM);
            break;
        }

        if (ind > jackpot) {
            /* 
             * Can only win as much as there is 
             */
            ind = jackpot;
        }

        sprintf(buf, "You have won %d coins!\n\r", ind);
        send_to_char(buf, ch);

        GET_GOLD(ch) += ind;
        jackpot -= ind;
        return (TRUE);
    }

    send_to_char("Sorry, you didn't win.\n\r", ch);
    return (TRUE);
}

/*
 * Proc for lennyas new zone.. If all stones are in altar, award prize 
 */
int altarofsin(struct char_data *ch, int cmd, char *argument,
               struct obj_data *obj, int type)
{
    struct obj_data *i,
                   *win;
    int             virtual,
                    x;
    char           *buf;
    int             hasStones[7] = { 0, 0, 0, 0, 0, 0, 0 };

    if (cmd != 438) {
        /* rub */
        return (FALSE);
    }

    dlog("in altar");

    argument = get_argument(argument, &buf);
    if (buf && !strcasecmp("altar", buf)) {
        /*
         * rub altar 
         */
        for (i = obj->contains; i; i = i->next_content) {
            virtual = MAX( 0, i->item_number );

            if (virtual < 51809 && virtual > 51801) {
                hasStones[virtual - 51802] = 1;
            }
        }

        /*
         * Check to see if all stones are present
         */
        for (x = 0; x < 7; x++) {
            if (hasStones[x] == 0) {
                send_to_char("As you rub the altar, it hums briefly, but "
                             "nothing else happens.\n\r", ch);
                return (TRUE);
            }
        }

        /*
         * yay, they're all there 
         */
        send_to_room("The Altar of Sin briefly glows, and a faint clicking "
                     "sound can be heard within.\n\r", ch->in_room);
        send_to_room("The Wisdom of Sin intones 'The prowess proven, the mind"
                     " excelled, the dice rolled.'\n\r", ch->in_room);
        send_to_room("The Wisdom of Sin intones 'Thus the reward may be "
                     "claimed.'\n\r", ch->in_room);

        /*
         * purge everything in altar
         */
        objectTakeFromRoom(obj);
        objectExtract(obj);

        obj = objectRead(51831, VIRTUAL);
        objectPutInRoom(obj, ch->in_room);

        /*
         * Load up the prize 
         */
        win = objectRead(randomitem(), VIRTUAL);
        if (!win) {
            Log("Invalid item in lennyas altar proc");
            return (FALSE);
        }
        objectPutInObject(win, obj);
        return (TRUE);
    }
    return (FALSE);
}

int randomitem(void)
{
    switch (number(0, 118)) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
        return 51809;
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
        return 51810;
    case 24:
    case 25:
    case 26:
    case 27:
    case 117:
    case 118:
        return 51811;
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
        return 51812;
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
        return 51813;
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
        return 51814;
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
        return 51815;
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
        return 51816;
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
        return 51817;
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
        return 51818;
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
        return 51819;
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
        return 51820;
    case 86:
        return 51821;
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
        return 51822;
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
        return 51823;
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
        return 51824;
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
        return 51825;
    default:
        return 51825;
    }
}

int applepie(struct char_data *ch, int cmd, char *argument,
             struct obj_data *obj, int type)
{
    struct char_data *hambre;
    struct obj_data *apple;

    if (cmd == 67) {
        /* put */

        hambre = get_char_vis_world(ch, "guardian gluttony Hambre 14000", NULL);

        if (!hambre) {
            Log("No Hambre found in applepie proc.");
            return (FALSE);
        }

        do_put(ch, argument, 67);
        apple = get_obj_in_list_vis(ch, "apple rotten poisoned", obj->contains);

        if (!apple) {
            return (TRUE);
        }

        if (apple->item_number == 51828) {
            send_to_room("\n\rA small army of servants enters the anteroom "
                         "and lifts up the apple pie.\n\r", ch->in_room);
            send_to_room("The servants groan under the pie's weight, yet "
                         "persevere and carry it through\n\r", ch->in_room);
            send_to_room("the eastern door. A few moments later, sounds of a "
                         "feeding frenzy drift can be\n\r", ch->in_room);
            send_to_room("heard, followed by some coughing. Some more "
                         "coughing... A strangled cry..\n\r", ch->in_room);
            GET_HIT(hambre) = -1;
            die(hambre, '\0');

            /*
             * purge pie 
             */
            objectExtract(obj);
        }
        return (TRUE);
    }
    return (FALSE);
}

/*
 * Proc for lennyas new zone.. If all stones are in altar, award prize 
 */
int trinketcount(struct char_data *ch, int cmd, char *argument,
                 struct obj_data *obj, int type)
{
    struct follow_type *f;
    struct char_data *k;
    struct obj_data *i;
    int             virtual;
    int             count = 0;

    if (cmd != 67) {
        /* put */
        return (FALSE);
    }

    dlog("in your stash");

    do_put(ch, argument, 67);

    for (i = obj->contains; i; i = i->next_content) {
        virtual = MAX( 0, i->item_number );

        if (virtual == 51833) {
            count++;
        }
    }
    /*
     * Check to see if all stones are present
     */
    if (count < 10) {
        return (TRUE);
    }
    command_interpreter(ch, "system A large gong sound echoes through-out the "
                            "lands.");

    /*
     * Send all in group too room 51878 
     * No group.. just you.. then move them
     */
    if (!IS_AFFECTED(ch, AFF_GROUP)) {
        char_from_room(ch);
        char_to_room(ch, 51878);
        do_look(ch, NULL, 0);
        return (TRUE);
    } else {
        if (ch->master) {
            k = ch->master;
        } else {
            k = ch;
        }
        for (f = k->followers; f; f = f->next) {
            if (IS_AFFECTED(f->follower, AFF_GROUP) &&
                f->follower->desc && ch != f->follower) {
                /*
                 * Move the followers 
                 */
                char_from_room(f->follower);
                char_to_room(f->follower, 51878);
                do_look(f->follower, NULL, 0);
            }
        }

        /*
         * send to master now 
         */
        if (ch->master && IS_AFFECTED(ch->master, AFF_GROUP) && 
            ch->master->desc && ch != ch->master) {
            /*
             * move the master 
             */
            char_from_room(ch->master);
            char_to_room(ch->master, 51878);
            do_look(ch->master, NULL, 0);
        }

        /*
         * Move you
         */
        char_from_room(ch);
        char_to_room(ch, 51878);
        do_look(ch, NULL, 0);
    }
    return (TRUE);
}

/*
 * berserker sword 
 */
#define BERSERK 329
int BerserkerItem(struct char_data *ch, int cmd, char *arg,
                  struct obj_data *obj, int type)
{
    if (type != PULSE_COMMAND) {
        return (FALSE);
    }
    if (ch->specials.fighting) {
        /* fighting! berserk! */
        if (!ch->equipment[WIELD]) {
            /* nothing wielded */
            return (FALSE);
        }

        if (ch->equipment[WIELD] != obj) {
            /* we are not wielded */
            return (FALSE);
        }

        if (!IS_SET(ch->specials.affected_by2, AFF2_BERSERK)) {
            /*
             * not berserked go berserk! 
             */
            do_berserk(ch, NULL, 0);
            return (FALSE);
        } else {
            /*
             * already berserked 
             */
            if (!number(0, 9)) {
                act("$n seems enraged to the point of exploding!", FALSE,
                    ch, 0, 0, TO_ROOM);
                act("Your anger wells up inside, you fling yourself at your "
                    "opponet!", FALSE, ch, 0, 0, TO_CHAR);
            }
            return (FALSE);
        }
    }
    return (FALSE);
}

int grayswandir(struct char_data *ch, int cmd, char *arg,
                struct room_data *rp, int type)
{
    char           *name;
    struct char_data *victim;
    struct obj_data *object;
    int             percent = 0;
    int             r_num = 0;
    int             vnum;
    extern struct dex_app_type dex_app[];

    if (cmd == 157) {
        /* Bash */
        if (!ch->equipment[HOLD]) {
            return (FALSE);
        }

        vnum = ch->equipment[HOLD]->item_number;

        if (vnum != GRAYSWANDIR) {
            return (FALSE);
        }
        if (!ch->skills) {
            return (TRUE);
        }
        if (check_peaceful(ch, "You feel too peaceful to "
                               "contemplate violence.\n\r")) {
            return (TRUE);
        }
        if ((IS_PC(ch) || IS_SET(ch->specials.act, ACT_POLYSELF)) &&
            !HasClass(ch, CLASS_WARRIOR | CLASS_PALADIN | CLASS_RANGER |
                          CLASS_BARBARIAN)) {
            send_to_char("You're no warrior!\n\r", ch);
            return (TRUE);
        }

        arg = get_argument(arg, &name);

        if (!name || !(victim = get_char_room_vis(ch, name))) {
            if (ch->specials.fighting) {
                victim = ch->specials.fighting;
            } else {
                send_to_char("Bash who?\n\r", ch);
                return (TRUE);
            }
        }

        if (!(victim = get_char_room_vis(ch, name))) {
            if (ch->specials.fighting) {
                victim = ch->specials.fighting;
            } else {
                send_to_char("Bash who?\n\r", ch);
                return (TRUE);
            }
        }

        if (victim == ch) {
            send_to_char("Aren't we funny today...\n\r", ch);
            return (TRUE);
        }

        if (MOUNTED(victim)) {
            send_to_char("You can't bash a mounted target!\n\r", ch);
            return (TRUE);
        }

        if (MOUNTED(ch)) {
            send_to_char("You can't bash while mounted!\n\r", ch);
            return (TRUE);
        }

        if (ch->attackers > 3) {
            send_to_char("There's no room to bash!\n\r", ch);
            return (TRUE);
        }

        if (victim->attackers >= 6) {
            send_to_char("You can't get close enough to them to bash!\n\r", ch);
            return (TRUE);
        }

        SetVictFighting(ch, victim);
        SetCharFighting(ch, victim);

        /* Don't make it too reliable -Lennya */
        percent = number(1, 130);
        percent -= dex_app[(int)GET_DEX(ch)].reaction * 10;
        percent += dex_app[(int)GET_DEX(victim)].reaction * 10;

        if (percent > ch->skills[SKILL_BASH].learned) {
            if (GET_POS(victim) > POSITION_DEAD) {
                act("$c0009You wildly swings $p at $N and fall over.",
                    FALSE, ch, ch->equipment[HOLD], victim, TO_CHAR);
                act("$c0009$n wildly swings $p at you and falls over.",
                    FALSE, ch, ch->equipment[HOLD], victim, TO_VICT);
                act("$c0009$n wildly swings $p at $N and falls over.",
                    FALSE, ch, ch->equipment[HOLD], victim, TO_NOTVICT);
                GET_POS(ch) = POSITION_SITTING;
            }
            LearnFromMistake(ch, SKILL_BASH, 0, 90);
            WAIT_STATE(ch, PULSE_VIOLENCE * 3);
        } else if (GET_POS(victim) > POSITION_DEAD) {
            act("$c0009You give $N a solid hit with $p that knocks $M to "
                "the ground.", FALSE, ch, ch->equipment[HOLD], victim, TO_CHAR);
            act("$c0009$n gives you a solid hit with $p that knocks you to "
                "the ground.", FALSE, ch, ch->equipment[HOLD], victim, TO_VICT);
            act("$c0009$n gives $N a solid hit with $p that knocks $M to "
                "the ground.", FALSE, ch, ch->equipment[HOLD], victim,
                TO_NOTVICT);
            GET_POS(victim) = POSITION_SITTING;
            WAIT_STATE(victim, PULSE_VIOLENCE * 2);
            GET_POS(victim) = POSITION_SITTING;
        }
        WAIT_STATE(ch, PULSE_VIOLENCE * 2);
    } else {
        return (FALSE);
    }
    return (TRUE);
}

int thunder_blue_pill(struct char_data *ch, int cmd, char *arg,
                      struct room_data *rp, int type)
{
    char           *buf;
    struct obj_data *i;
    struct obj_data *obj;
    int             has_pill = 0;

    if (cmd == 12) {
        /* 
         * Eat 
         */
        arg = get_argument(arg, &buf);

        if (!buf || !(obj = get_obj_in_list_vis(ch, buf, ch->carrying))) {
            act("You can't find it!", FALSE, ch, 0, 0, TO_CHAR);
            return (TRUE);
        }

        for (i = ch->carrying; i && !has_pill; i = i->next_content) {
            if (i->item_number == BLUE_PILL) {
                has_pill = 1;
            }
        }

        if (has_pill == 1) {
            if (obj->item_number != BLUE_PILL) {
                return (FALSE);
            }
            act("$n eats $p", TRUE, ch, obj, 0, TO_ROOM);
            act("You eat $p.", FALSE, ch, obj, 0, TO_CHAR);
            objectExtract(obj);

            if (time_info.hours > 6) {
                if (time_info.hours < 20) {
                    obj = objectRead(PEN_MIGHT, VIRTUAL);
                    objectGiveToChar(obj, ch);
                    send_to_char("Elamin's Pen of Might bursts out of thin"
                                 " air and lands in your hands.\n\r", ch);
                    act("Elamin's Pen of Might bursts out of thin air and"
                        " lands in $n's hands.", FALSE, ch, 0, 0, TO_ROOM);
                } else {
                    send_to_char("You realize too late that you chose the "
                                 "wrong pill.\n\r", ch);
                    act("$n realizes too late that they chose the wrong pill "
                        "as they fall to the ground.", FALSE, ch, 0, 0, 
                        TO_ROOM);
                    GET_HIT(ch) = -1;
                    die(ch, '\0');
                }
            } else {
                send_to_char("You realize too late that you chose the wrong "
                             "pill.\n\r", ch);
                act("$n realizes too late that they chose the wrong pill as "
                    "they fall to the ground.", FALSE, ch, 0, 0, TO_ROOM);
                GET_HIT(ch) = -1;
                die(ch, '\0');
            }
            return (TRUE);
        }
    }

    return (FALSE);
}

int thunder_black_pill(struct char_data *ch, int cmd, char *arg,
                       struct room_data *rp, int type)
{
    char           *buf;
    struct obj_data *i;
    struct obj_data *obj;
    int             has_pill = 0;

    if (cmd == 12) {
        /* Eat */
        arg = get_argument(arg, &buf);
        if (!buf || !(obj = get_obj_in_list_vis(ch, buf, ch->carrying))) {
            act("You can't find it!", FALSE, ch, 0, 0, TO_CHAR);
            return (TRUE);
        }

        for (i = ch->carrying; i && !has_pill; i = i->next_content) {
            if (i->item_number == BLACK_PILL) {
                has_pill = 1;
            }
        }

        if (has_pill == 1) {
            if (obj->item_number != BLACK_PILL) {
                return (FALSE);
            }
            act("$n eats $p", TRUE, ch, obj, 0, TO_ROOM);
            act("You eat $p.", FALSE, ch, obj, 0, TO_CHAR);
            objectExtract(obj);

            if (time_info.hours < 7 || time_info.hours > 19) {
                obj = objectRead(PEN_MIGHT, VIRTUAL);
                objectGiveToChar(obj, ch);
                send_to_char("Elamin's Pen of Might bursts out of thin air"
                             " and lands in your hands.\n\r", ch);
                act("Elamin's Pen of Might bursts out of thin air and lands"
                    " in $n's hands.", FALSE, ch, 0, 0, TO_ROOM);
            } else {
                send_to_char("You realize too late that you chose the wrong "
                             "pill.\n\r", ch);
                act("$n realizes too late that they chose the wrong pill as "
                    "they fall to the ground.", FALSE, ch, 0, 0, TO_ROOM);
                GET_HIT(ch) = -1;
                die(ch, '\0');
            }
            return (TRUE);
        }
    }

    return (FALSE);
}

int thunder_sceptre_one(struct char_data *ch, int cmd, char *arg,
                        struct room_data *rp, int type)
{
    char           *arg1;
    char           *arg2;
    struct obj_data *obj;
    struct obj_data *obj1;
    struct obj_data *obj2;

    if (cmd == 67) {
        /* 
         * put 
         */
        arg = get_argument(arg, &arg1);
        arg = get_argument(arg, &arg2);

        if (!arg1 || !(obj1 = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
            return (FALSE);
        }
        if (!arg2 || !(obj2 = get_obj_in_list_vis(ch, arg2, ch->carrying))) {
            return (FALSE);
        }
        if (obj1->item_number != EYE_DRAGON) {
            return (FALSE);
        }
        if (obj2->item_number != DRAGON_SCEPTRE_ONE) {
            return (FALSE);
        }
        act("The sceptre rumbles slightly as it unites with the eye of the "
            "dragon.", FALSE, ch, 0, 0, TO_ROOM);
        act("The sceptre rumbles slightly as it unites with the eye of the "
            "dragon.", FALSE, ch, 0, 0, TO_CHAR);
        objectExtract(obj1);
        objectExtract(obj2);

        obj = objectRead(DRAGON_SCEPTRE_TWO, VIRTUAL);
        objectGiveToChar(obj, ch);
        return (TRUE);
    }

    return (FALSE);
}

int thunder_sceptre_two(struct char_data *ch, int cmd, char *arg,
                        struct room_data *rp, int type)
{
    char           *arg1;
    char           *arg2;
    struct obj_data *obj;
    struct obj_data *obj1;
    struct obj_data *obj2;
    struct char_data *tmp,
                   *tmp2;
    struct room_data *room;

    if (cmd == 67) {
        /* put */
        arg = get_argument(arg, &arg1);
        arg = get_argument(arg, &arg2);

        if (!arg1 || !(obj1 = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
            return (FALSE);
        }
        if (!arg2 || !(obj2 = get_obj_in_list_vis(ch, arg2, ch->carrying))) {
            return (FALSE);
        }

        if (obj1->item_number != EYE_DRAGON) {
            return (FALSE);
        }
        if (obj2->item_number != DRAGON_SCEPTRE_TWO) {
            return (FALSE);
        }
        act("The sceptre rumbles slightly as it unites with the eye of the "
            "dragon.", FALSE, ch, 0, 0, TO_ROOM);
        act("The sceptre rumbles slightly as it unites with the eye of the "
            "dragon.", FALSE, ch, 0, 0, TO_CHAR);
        act("The sceptre flies out of $n's grasp and spins rapidly in the air.",
            FALSE, ch, 0, 0, TO_ROOM);
        act("The sceptre flies out of your grasp and spins rapidly in the air.",
            FALSE, ch, 0, 0, TO_CHAR);
        act("A blinding white light fills the room.  You blink and find "
            "yourself in a new room.", FALSE, ch, 0, 0, TO_ROOM);
        act("A blinding white light fills the room.  You blink and find "
            "yourself in a new room.", FALSE, ch, 0, 0, TO_CHAR);
        objectExtract(obj1);
        objectExtract(obj2);

        obj = objectRead(DRAGON_SCEPTRE_ONE, VIRTUAL);
        objectPutInRoom(obj, ch->in_room);

        obj = objectRead(EYE_DRAGON, VIRTUAL);
        objectPutInRoom(obj, ch->in_room);
        obj = objectRead(EYE_DRAGON, VIRTUAL);
        objectPutInRoom(obj, ch->in_room);

        room = real_roomp(ch->in_room);
        for (tmp = room->people; tmp; tmp = tmp2) {
            tmp2 = tmp->next_in_room;
            if (in_group(ch, tmp) && !tmp->specials.fighting &&
                (IS_PC(tmp) || IS_SET(tmp->specials.act, ACT_POLYSELF)) && 
                IS_AFFECTED(tmp, AFF_GROUP)) {

                char_from_room(tmp);
                char_to_room(tmp, CALM_BEFORE_STORM);
                do_look(tmp, NULL, 0);
            }
        }
        return (TRUE);
    }

    return (FALSE);
}

/*
 * @Name: This is the chest part of the royal rumble proc. @description:
 * Once there is only 1 person left in the arena, the chest will open.
 * @Author: Greg Hovey (Banon) @Assigned to obj/mob/room: Obj(51152) 
 */
#define RUMBLE_ZONE 188
int chestproc(struct char_data *ch, int cmd, char *argument,
              struct obj_data *obj, int type)
{
    if (cmd != 99) {
        /* 
         * open chest
         */
        return (FALSE);
    }

    dlog("in chestproc");

    if (countPeople(RUMBLE_ZONE) > 1) {
        oldSendOutput(ch, "The chest seems to resist your touch...", ch);
        return (TRUE);
    } else {
        return (FALSE);
    }
}

/*
 * @Name:           mirrorofopposition 
 * @description:    An obj proc which will dopplegang a PC.  
 *                  Copies just about everything I could think 
 *                  of, makes mob hate him, and attack him using 
 *                  his own equipment.  Players will probably really 
 *                  hate being on the receiving end of their +30 hasted
 *                  damrolls. 
 * @Author:         Rick Peplinski (Talesian) 
 * @Assigned to:    obj(37821) 
 */

/**
 * @todo redo as we have no reimb support any more
 */
int mirrorofopposition(struct char_data *ch, int cmd, char *arg,
                       struct obj_data *obj, int type)
{
    struct affected_type af2;
    struct char_data *mob;
    int             i;
    int             maxlevel;
    struct affected_type *af;
    struct obj_file_u st;
    struct obj_data *tempobj;
    int             total_equip_cost;
    char           *buf1;
    char           *buf2;
    FILE           *fl;

    if (obj->in_room == -1 || cmd != 15 || IS_IMMORTAL(ch)) {
        return (FALSE);
    }

    arg = get_argument(arg, &buf1);
    arg = get_argument(arg, &buf2);

    if (!buf1 || !buf2 || (strcmp(buf1, "mirror") && strcmp(buf2, "mirror"))) {
        return (FALSE);
    }

    /* 
     * CreateAMob -> generic mob (naked) -> no follower, no random attack
     */
    mob = CreateAMob(ch, GENERICMOBVNUM, 0,
                     "A figure suddenly steps out of the mirror.");

    /* 
     * start doing pc info:
     * name, title, classes, hitroll = MAX (1,20 - biggestlevel*.5), armor 
     * will be done by what's being worn
     */
    sprintf(buf1, "%s Bizarro", GET_NAME(ch));
    mob->player.name = (char *) strdup(buf1);
    mob->player.short_descr = (char *) strdup(GET_NAME(ch));
    sprintf(buf1, "%s is standing here.", ch->player.title);
    mob->player.long_descr = (char *) strdup(buf1);
    mob->player.class = ch->player.class;

    for (i = 0; i < 12; i++) {
        mob->player.level[i] = ch->player.level[i];
    }

    maxlevel = GetMaxLevel(mob);
    GET_HITROLL(mob) = MAX(1, 20 - (maxlevel >> 1));
    /*
     * max (hp, mana, move) current (stats, race, spell affects)
     */
    mob->points.max_hit = GET_MAX_HIT(ch);
    mob->points.max_mana = GET_MAX_MANA(ch);
    mob->points.max_move = GET_MAX_MOVE(ch);
    mob->points.hit = GET_MAX_HIT(ch);
    mob->points.mana = GET_MAX_MANA(ch);
    mob->points.move = GET_MAX_MOVE(ch);
    mob->mult_att = ch->mult_att;
    GET_ALIGNMENT(mob) = GET_ALIGNMENT(ch);

    for (af = ch->affected; af; af = af->next) {
        affect_to_char(mob, af);
    }

    GET_RACE(mob) = GET_RACE(ch);
    GET_RSTR(mob) = GET_RSTR(ch);
    GET_RADD(mob) = GET_RADD(ch);
    GET_RCON(mob) = GET_RCON(ch);
    GET_RDEX(mob) = GET_RDEX(ch);
    GET_RWIS(mob) = GET_RWIS(ch);
    GET_RINT(mob) = GET_RINT(ch);
    GET_RCHR(mob) = GET_RCHR(ch);

#ifdef REIMB
    sprintf(buf1, "reimb/%s", lower(ch->player.name));
    if (!(fl = fopen(buf1, "r+b"))) {
        act("The figure looks around, and promptly disappears!", TRUE, mob,
            0, 0, TO_ROOM);
        char_from_room(mob);
        extract_char(mob);
        return (TRUE);
    }

    rewind(fl);

    if (!ReadObjs(fl, &st)) {
        act("The figure looks around, and promptly disappears!", TRUE, mob,
            0, 0, TO_ROOM);
        char_from_room(mob);
        extract_char(mob);
        return (TRUE);
    }

    for (i = 0; i < MAX_WEAR; i++) {
        if (mob->equipment[i])
            objectExtract(unequip_char(mob, i));
    }
    while (mob->carrying) {
        objectExtract(mob->carrying);
    }

    obj_store_to_char(mob, &st);
#endif

    while (mob->carrying) {
        objectExtract(mob->carrying);
    }

    /*
     * set all equipment to useless somehow (anti_everything? anti_gne?
     * norent? anti_sun? Organic_decay?)
     * lennya said maybe that timer could be used for any equipment, not
     * just specific equipment
     */
    total_equip_cost = 0;
    for (i = 0; i < MAX_WEAR; i++) {
        if (mob->equipment[i]) {

            total_equip_cost += mob->equipment[i]->cost;
            mob->equipment[i]->timer = 20;
            if (ITEM_TYPE(mob->equipment[i]) == ITEM_TYPE_CONTAINER) {
                while ((tempobj = mob->equipment[i]->contains)) {
                    objectExtract(tempobj);
                }
            }

            if(IS_OBJ_STAT(mob->equipment[i], anti_flags, ITEM_ANTI_GOOD)) {
                REMOVE_BIT(mob->equipment[i]->anti_flags, ITEM_ANTI_GOOD);
            }

            if(IS_OBJ_STAT(mob->equipment[i], anti_flags, ITEM_ANTI_EVIL)) {
                REMOVE_BIT(mob->equipment[i]->anti_flags, ITEM_ANTI_EVIL);
            }

            if(IS_OBJ_STAT(mob->equipment[i], anti_flags, ITEM_ANTI_NEUTRAL)) {
                REMOVE_BIT(mob->equipment[i]->anti_flags, ITEM_ANTI_NEUTRAL);
            }

            if(!IS_OBJ_STAT(mob->equipment[i], anti_class, 
                            ITEM_ANTI_NECROMANCER)) {
                SET_BIT(mob->equipment[i]->anti_class, ITEM_ANTI_NECROMANCER);
            }

            if(!IS_OBJ_STAT(mob->equipment[i], anti_class, ITEM_ANTI_CLERIC)) {
                SET_BIT(mob->equipment[i]->anti_class, ITEM_ANTI_CLERIC);
            }

            if(!IS_OBJ_STAT(mob->equipment[i], anti_class, ITEM_ANTI_MAGE)) {
                SET_BIT(mob->equipment[i]->anti_class, ITEM_ANTI_MAGE);
            }

            if(!IS_OBJ_STAT(mob->equipment[i], anti_class, ITEM_ANTI_THIEF)) {
                SET_BIT(mob->equipment[i]->anti_class, ITEM_ANTI_THIEF);
            }

            if(!IS_OBJ_STAT(mob->equipment[i], anti_class, ITEM_ANTI_FIGHTER)) {
                SET_BIT(mob->equipment[i]->anti_class, ITEM_ANTI_FIGHTER);
            }

            if(!IS_OBJ_STAT(mob->equipment[i], anti_flags, ITEM_ANTI_MEN)) {
                SET_BIT(mob->equipment[i]->anti_flags, ITEM_ANTI_MEN);
            }

            if(!IS_OBJ_STAT(mob->equipment[i], anti_flags, ITEM_ANTI_WOMEN)) {
                SET_BIT(mob->equipment[i]->anti_flags, ITEM_ANTI_WOMEN);
            }

            if(!IS_OBJ_STAT(mob->equipment[i], anti_flags, ITEM_ANTI_SUN)) {
                SET_BIT(mob->equipment[i]->anti_flags, ITEM_ANTI_SUN);
            }

            if(!IS_OBJ_STAT(mob->equipment[i], anti_class, 
                            ITEM_ANTI_BARBARIAN)) {
                SET_BIT(mob->equipment[i]->anti_class, ITEM_ANTI_BARBARIAN);
            }

            if(!IS_OBJ_STAT(mob->equipment[i], anti_class, ITEM_ANTI_RANGER)) {
                SET_BIT(mob->equipment[i]->anti_class, ITEM_ANTI_RANGER);
            }

            if(!IS_OBJ_STAT(mob->equipment[i], anti_class, ITEM_ANTI_PALADIN)) {
                SET_BIT(mob->equipment[i]->anti_class, ITEM_ANTI_PALADIN);
            }

            if(!IS_OBJ_STAT(mob->equipment[i], anti_class, ITEM_ANTI_PSI)) {
                SET_BIT(mob->equipment[i]->anti_class, ITEM_ANTI_PSI);
            }

            if(!IS_OBJ_STAT(mob->equipment[i], anti_class, ITEM_ANTI_MONK)) {
                SET_BIT(mob->equipment[i]->anti_class, ITEM_ANTI_MONK);
            }

            if(!IS_OBJ_STAT(mob->equipment[i], anti_class, ITEM_ANTI_DRUID)) {
                SET_BIT(mob->equipment[i]->anti_class, ITEM_ANTI_DRUID);
            }
        }
    }

    /* 
     * if has class to have 'normal' spells (sanc, fs, bb), add the affect 
     * (like casting, not by setting perma-flag)
     */
    if (IS_SET(mob->player.class, CLASS_NECROMANCER) &&
        !affected_by_spell(mob, SPELL_CHILLSHIELD) &&
        GET_LEVEL(ch, NECROMANCER_LEVEL_IND) > 39) {
        af2.type = SPELL_CHILLSHIELD;
        af2.duration = 3;
        af2.modifier = 0;
        af2.location = 0;
        af2.bitvector = AFF_CHILLSHIELD;
        affect_to_char(mob, &af2);
    }

    if (IS_SET(mob->player.class, CLASS_MAGIC_USER | CLASS_PSI) && 
        !IS_SET(mob->player.class, CLASS_CLERIC) &&
        !affected_by_spell(mob, SPELL_FIRESHIELD) &&
        (GET_LEVEL(ch,PSI_LEVEL_IND) > 14 ||
        GET_LEVEL(ch,MAGE_LEVEL_IND) > 39)) {
        af2.type = SPELL_FIRESHIELD;
        af2.duration = 3;
        af2.modifier = 0;
        af2.location = 0;
        af2.bitvector = AFF_FIRESHIELD;
        affect_to_char(mob, &af2);
    }

    if (IS_SET(mob->player.class, CLASS_CLERIC)) {
        if (!affected_by_spell(mob, SPELL_SANCTUARY)) {
            af2.type = SPELL_SANCTUARY;
            af2.duration = 3;
            af2.modifier = 0;
            af2.location = APPLY_NONE;
            af2.bitvector = AFF_SANCTUARY;
            affect_to_char(mob, &af2);
        }

        if (!affected_by_spell(mob, SPELL_BLADE_BARRIER) &&
            GET_LEVEL(ch,CLERIC_LEVEL_IND) > 44) {
            af2.type = SPELL_BLADE_BARRIER;
            af2.duration = 3;
            af2.modifier = 0;
            af2.location = APPLY_NONE;
            af2.bitvector = AFF_BLADE_BARRIER;
            affect_to_char(mob, &af2);
        }
    }
    
    /* 
     * Make him act like class he is if possible:
     */
    if (IS_SET(mob->player.class, CLASS_NECROMANCER)) {
        SET_BIT(mob->specials.act_class, ACT_NECROMANCER);
    }

    if (IS_SET(mob->player.class, CLASS_MAGIC_USER)) {
        SET_BIT(mob->specials.act_class, ACT_MAGIC_USER);
    }

    if (IS_SET(mob->player.class, CLASS_CLERIC)) {
        SET_BIT(mob->specials.act_class, ACT_CLERIC);
    }

    if (IS_SET(mob->player.class, CLASS_WARRIOR)) {
        SET_BIT(mob->specials.act_class, ACT_WARRIOR);
    }

    if (IS_SET(mob->player.class, CLASS_THIEF)) {
        SET_BIT(mob->specials.act_class, ACT_THIEF);
    }

    if (IS_SET(mob->player.class, CLASS_DRUID)) {
        SET_BIT(mob->specials.act_class, ACT_DRUID);
    }

    if (IS_SET(mob->player.class, CLASS_MONK)) {
        SET_BIT(mob->specials.act_class, ACT_MONK);
    }

    if (IS_SET(mob->player.class, CLASS_BARBARIAN)) {
        SET_BIT(mob->specials.act_class, ACT_BARBARIAN);
    }

    if (IS_SET(mob->player.class, CLASS_PALADIN)) {
        SET_BIT(mob->specials.act_class, ACT_PALADIN);
    }

    if (IS_SET(mob->player.class, CLASS_RANGER)) {
        SET_BIT(mob->specials.act_class, ACT_RANGER);
    }

    if (IS_SET(mob->player.class, CLASS_PSI)) {
        SET_BIT(mob->specials.act_class, ACT_PSI);
    }

    if (IsGiant(mob)) {
        SET_BIT(mob->specials.act, ACT_HUGE);
    }

    /* 
     * set experience, figure .005 of players total exp + equipment cost?
     */
    mob->points.exp = GET_EXP(ch) * .005 + total_equip_cost;
    GET_ALIGNMENT(mob) = -1 * GET_ALIGNMENT(ch);

    /* 
     * have him go to town on character
     */

    MobHit(mob, ch, 0);

    return (TRUE);
}

int qp_potion(struct char_data *ch, int cmd, char *arg)
{
    char           *arg1;
    struct obj_data *found;
    struct obj_data *obj;
    int             has_pot = 0;

    if (cmd != 206) {
        /* 
         * quaff 
         */
        return (FALSE);
    }

    arg = get_argument(arg, &arg1);

    if (!arg1 || !(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
        act("You do not have that item.", FALSE, ch, 0, 0, TO_CHAR);
        return (TRUE);
    }

    for (found = ch->carrying; found && !has_pot; found = found->next_content) {
        if (found->item_number == QUEST_POTION) {
            has_pot = 1;
        }
    }

    if (has_pot == 1) {
        if (obj->item_number != QUEST_POTION) {
            return (FALSE);
        }
        act("$n quaffs $p.", TRUE, ch, obj, 0, TO_ROOM);
        act("You quaff $p which dissolves.", FALSE, ch, obj, 0, TO_CHAR);
        act("You have claimed your quest point!", FALSE, ch, obj, 0, TO_CHAR);
        qlog(ch, "quaffed a quest potion.");

        ch->player.q_points++;
        do_save(ch, NULL, 0);
        objectExtract(obj);
        return (TRUE);
    }
    return (FALSE);
}

int ships_helm(struct char_data *ch, int cmd, char *argument,
               struct obj_data *obj, int type)
{
    static char    *keywords[] = {
        "north",
        "east",
        "south",
        "west",
        "up",
        "down"
    };
    int             keyword_no = 0;
    char           *buf;

    if (cmd == 621) {
        /* 
         * disembark 
         */
        return disembark_ship(ch, cmd, argument, obj, type);
    }

    if (cmd == 625) {
        return steer_ship(ch, cmd, argument, obj, type);
    }

    return (FALSE);

    argument = get_argument(argument, &buf);

    if (!buf) {                
        send_to_char("Sail in which direction?", ch);
        return (TRUE);
    }

    keyword_no = search_block(buf, keywords, FALSE);

    if ((keyword_no == -1)) {
        send_to_char("Sail in which direction?", ch);
        return (TRUE);

    }

    if (!CanSail(obj, keyword_no)) {
        send_to_char("You can't sail that way, you'd be bound to sink the "
                     "ship!!\n\r", ch);
        return (TRUE);
    }

    oldSendOutput(ch, "You sail %sward.\n\r", keywords[keyword_no]);

    switch (keyword_no) {
    case 0:         
        /* 
         * North
         */
        GET_XCOORD(obj)--;
        break;
    case 1:         
        /* 
         * East
         */
        GET_YCOORD(obj)++;
        break;
    case 2:         
        /* 
         * south
         */
        GET_XCOORD(obj)++;
        break;
    case 3:         
        /* 
         * west
         */
        GET_YCOORD(obj)--;
        break;
    default:
        break;
    }

    printmap(ch, GET_XCOORD(obj), GET_YCOORD(obj), 5, 10);
    return (TRUE);
}

int level_limiter(struct char_data *ch, int cmd, char *argument,
                  struct obj_data *obj, int type)
{   
    char    buf[MAX_STRING_LENGTH];
    int     dam = 0,
            i;
    char    *arg, *arg1;
    int     zapit = FALSE;
    int     inroom = FALSE;
    struct obj_data *tmp_obj;
    
    if( !ch || !obj ) {
        return( FALSE );
    }

    if( (!obj->carried_by && !obj->equipped_by && !obj->in_obj)) {
        /* Zap this bitch, it's in a room not on a char */
        zapit = TRUE;
        inroom = TRUE;
    }
    
    switch( cmd ) {
    case 72:    /* give */
    case 304:   /* auction */
    case 514:   /* donate */
    case 57:    /* sell */
    case 67:    /* put */
        arg = strdup(argument);
        argument = arg;

        argument = get_argument(argument, &arg1);
        if( arg1 ) {
            tmp_obj = get_obj_in_list(arg1, ch->carrying);
            if( obj != tmp_obj && strncasecmp(arg1, "all", 3)) {
                free(arg);
                return(FALSE);
            }

            zapit = TRUE;
            inroom = TRUE;
        }
        free(arg);
        break;
    default:
        break;
    }

    if( IS_IMMORTAL(ch) ) {
        return( FALSE );
    }

    if (GetMaxLevel(ch) >= 41) {
        strcpy(buf, "The $p takes an intense disliking to you and explodes, "
                    "burning you severely!");
        act(buf, FALSE, ch, obj, NULL, TO_CHAR);

        dam = 5 * (GetMaxLevel(ch) - 41);
        dam = MIN( dam, GET_HIT(ch) / 2 );
        dam = MAX( dam, 0 );

        DoDamage(ch, ch, dam, SPELL_FIRESHIELD);
        
        zapit = TRUE;
    }

    if( zapit ) {
        strcpy(buf, "The $p explodes in a large ball of flame and a loud "
                    "BANG!" );
        act(buf, FALSE, ch, obj, NULL, TO_ROOM);
        if( inroom ) {
            act(buf, FALSE, ch, obj, NULL, TO_CHAR);
        }

        Log( "%s exploded %s and took %d damage", GET_NAME(ch), 
             obj->short_description, dam );

        if( obj->carried_by ) {
            objectTakeFromChar(obj);
        } else if( obj->equipped_by ) {
            tmp_obj = get_object_in_equip(ch, obj->name, 
                                          obj->equipped_by->equipment, &i );
            unequip_char(obj->equipped_by, i);
        } else if( obj->in_obj ) {
            objectTakeFromObject(obj);
        }
        objectExtract(obj);
    }

    return(zapit);
}

int mazekeeper_portal(struct char_data *ch, int cmd, char *argument,
                      struct obj_data *obj, int type)
{

    if (!cmd || cmd != 7 || !ch || !argument) {
        return( FALSE );
    }
    if (cmd == 7 && GetMaxLevel(ch) >= 41 && !IS_IMMORTAL(ch)){
        objectTakeFromRoom(obj);
        objectExtract(obj);
        act("The ring of blazing white light suddenly vanishes!", 
            FALSE, ch, obj, NULL, TO_ROOM);
        act("The ring of blazing white light suddenly vanishes!",
            FALSE, ch, obj, NULL, TO_CHAR);
        return( TRUE );
    }
    return( FALSE );
}

/*
 * can they sail in that directioN?? 
 */
int CanSail(struct obj_data *obj, int direction)
{
    int             x = 0,
                    y = 0;

    x = GET_XCOORD(obj);
    y = GET_YCOORD(obj);

    switch (direction) {
    case 0:
        /* 
         * North
         */
        x--;
        break;
    case 1:
        /* 
         * East
         */
        y++;
        break;
    case 2:
        /* 
         * south
         */
        x++;
        break;
    case 3:
        /* 
         * west
         */
        y--;
        break;
    default:
        break;
    }

    if (oceanmap[x][y] == '~') {
        return (TRUE);
    } else if (oceanmap[x][y] == '@') {
        /* 
         * Entered port city.. lets place a ship in the board city
         */
        return (TRUE);
    } else if (oceanmap[x][y] == ':') {
        return (TRUE);
    } else {
        return (FALSE);
    }
}

/*
 * lets print the map to the screen 
 */
void printmap(struct char_data *ch, int x, int y, int sizex, int sizey)
{
    int             loop = 0;
    void            printColors(struct char_data *ch, char *buf);
    char            buf[256];
    char            buf2[256];
    oldSendOutput(ch, "Coords: %d-%d.\n\r", x, y);
    sprintf(buf, "\n\r$c000B]$c000W");

    for (loop = 0; loop < sizey * 2 + 1; loop++) {
        sprintf(buf, "%s=", buf);
    }

    sprintf(buf, "%s$c000B[$c000w\n\r", buf);
    send_to_char(buf, ch);

    for (loop = 0; loop < sizex * 2 + 1; loop++) {
        /* 
         * move that row of the ocean map into buf 
         */
        sprintf(buf, "%s", oceanmap[x - sizex + loop]);

        if (loop == sizex) {
            buf[y] = 'X';
        }
        /* 
         * mark of the end of where they should see 
         */
        buf[y + sizey + 1] = '\0';
        /* 
         * move to the start of where they should see on that row 
         * Print that mofo out 
         */
        sprintf(buf2, "|%s|\n\r", &buf[y - sizey]);
        printColors(ch, buf2);
    }

    sprintf(buf, "$c000B]$c000W");
    for (loop = 0; loop < sizey * 2 + 1; loop++) {
        sprintf(buf, "%s=", buf);
    }

    sprintf(buf, "%s$c000B[$c000w", buf);
    send_to_char(buf, ch);
}

/*
 * Lets go through and see what terrain needs what color 
 */
void printColors(struct char_data *ch, char *buf)
{
    int             x = 0;
    char            buffer[2048];
    char            last = ' ';

    buffer[0] = '\0';

    while (buf[x] != '\0') {
        switch (buf[x]) {
        case '~':
            if (last == '~') {
                strcat(buffer, "~");
            } else {
                strcat(buffer, "$c000b~");
                last = '~';
            }
            break;
        case '+':
            if (last == '+') {
                strcat(buffer, "+");
            } else {
                strcat(buffer, "$c000G+");
                last = '+';
            }
            break;
        case '^':
            if (last == '^') {
                strcat(buffer, "^");
            } else {
                strcat(buffer, "$c000Y^");
                last = '^';
            }
            break;
        case '.':
            if (last == '.') {
                strcat(buffer, ".");
            } else {
                strcat(buffer, "$c000y.");
                last = '.';
            }
            break;
        default:
            if (last == buf[x]) {
                sprintf(buffer, "%s%c", buffer, buf[x]);
            } else {
                sprintf(buffer, "%s$c000w%c", buffer, buf[x]);
                last = buf[x];
            }
            break;
        }
        x++;
    }

    send_to_char(buffer, ch);
}

/*
 * vim:ts=4:sw=4:ai:et:si:sts=4
 */
